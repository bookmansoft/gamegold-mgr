# antd pro 阅读笔记

## 通讯机制

在当前的模拟环境下，基本信息流如下所示：
pages -> models -> services -> mock | remoteServer

在具体的 model 中，基本信息流如下所示：
effect(可以理解为action) -> 获取数据(远程或本地) -> reducer -> state

## 路由机制

路由管理由 roadhog 切换为了 umi ，可以简单的视为  webpack + router 的混合体，需要仔细阅读umi官网上的使用说明

page内路由跳转的方式：
router.push

model内路由跳转的方式：
routerRedux.push
routerRedux.replace
window.location.href = redirect;

## 烦人的缓存

```js
  return fetch(url, newOptions)
    .then(checkStatus)
    .then(response => cachedSave(response, hashcode))
```
cachedSave缓存了频繁发起的请求的结果，但也容易造成很多歧义性现象，建议调测阶段直接屏蔽

## 调测随笔
1. 提交Git库总是失败，什么原因呢？
可以删除如下语句（提交检测），以提高提交速度或避免提交失败
  "scripts": {
    "precommit": "npm run lint-staged",
    ...
  }
不过似乎并不是一个好主意，还是改进书写规范吧

2. 前端环境和后端环境的差异

制作一个前后端兼容的项目，需要考虑很多因素，例如前端页面上 Buffer 对象并不能直接使用，等等。

今天在调测 HMAC256 算法时碰到此类问题，原本的写法:
```js
const crypto = require('crypto')
const hmac = crypto.createHmac('sha256', random);
let sig = hmac.update(token).digest('hex'); //计算并附加访问令牌
```

考虑到前端页面无法使用 Node 库文件 crypto ， 因此引入了第三方包 crypto-js
使用 npm i crypto-js 安装后使用报错，试图使用 bower 安装失败，试图直接引用文件，发现文件来源一般都指向 google-code ... 非常的郁闷

接下来找到了一个前端函数库 create-hmac ， 其内部使用的 Buffer 对象则来自 safe-buffer , 代码如下：
```js
var createHmac = require('create-hmac/browser');  // 加 '/browser' 表示引用其browser版本，否则它会直接调用 Node 的 crypto 库
var hmac = createHmac('sha256', random);          // 传入字符串，函数内部会使用 safe-buffer 进行转化
console.log(hmac.update(token).digest('hex'));    // 加密 token 并转化为字符串，可以指定不同格式如 hex
```

终于通过了测试...

## 一些有趣的软件

### yarn

Javascript依赖管理器，FB、Google等机构和一些程序大咖联合推出，有超越npm的趋势，特点是离线缓存，可以快速完成依赖包安装。

### pnpm

Javascript依赖管理器，速度比yarn更快，但目前普及率尚不及yarn和npm

### now

看它的网站标题：
Now – Global Serverless Deployments， Serverless 部署服务商

下面以now做线上部署演示
```bash
$ yarn global add now
$ now ./dist
```
可惜的是，到了邮件验证环节就再也过不去了，难道被墙了？
